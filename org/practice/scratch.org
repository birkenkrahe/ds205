#+startup: overview hideblocks indent entitiespretty:
#+property: header-args:python :python python3 :session *Python* :results output :exports both :noweb yes :tangle yes:
* Finding connectors

The story so far: finding key connectors in a network of friends:
#+begin_src python
  users = [
        { "id": 0, "name": "Hero" },
        { "id": 1, "name": "Dunn" },
        { "id": 2, "name": "Sue" },
        { "id": 3, "name": "Chi" },
        { "id": 4, "name": "Thor" },
        { "id": 5, "name": "Clive" },
        { "id": 6, "name": "Hicks" },
        { "id": 7, "name": "Devin" },
        { "id": 8, "name": "Kate" },
        { "id": 9, "name": "Klein" }
  ]

  friendships = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4),
                 (4, 5), (5, 6), (5, 7), (6, 8), (7, 8), (8, 9)]

  #[print(_) for _ in friendship_pairs]

  friendships = {user["id"]: [] for user in users} # dictionary comprehension

  #[print(f'user: {key}, value: {value}') for key,value in friendships.items()]

  for i, j in friendship_pairs:
        friendships[i].append(j) # add j as a friend of user i
        friendships[j].append(i) # add i as a friend of user j

  #[print(key,value) for key,value in friendships.items()]        

  def number_of_friends(user):
    """How many friends does `user` have?"""
    user_id = user["id"]   # get the key
    friend_ids = friendships[user_id]    # get the friends
    return len(friend_ids)   # return the number of friends

  total_connections = sum(number_of_friends(user) for user in users)
  #print(total_connections)

  num_users = len(users) # length of `user` list = number of users
  avg_connections = total_connections / num_users  # arithmetic average
  #print(avg_connections)

  num_friends_by_id = [(user["id"], number_of_friends(user)) for user in users]
  print(num_friends_by_id)

  # sort the list
  num_friends_by_id.sort(
    # by num_friends
    key=lambda id_and_friends: id_and_friends[1],
    # from largest to smallest
    reverse=True)

  # print the result
  print(num_friends_by_id)
  #+end_src

#+RESULTS:
: [(0, 2), (1, 3), (2, 3), (3, 3), (4, 2), (5, 3), (6, 2), (7, 2), (8, 3), (9, 1)]
: [(1, 3), (2, 3), (3, 3), (5, 3), (8, 3), (0, 2), (4, 2), (6, 2), (7, 2), (9, 1)]

* Finding friends of friends

- Return the friends of a user's friend (~foaf~):
  #+begin_src python

  #+end_src

- Call ~foaf~ on ~users[0]~ (Hero):
  #+begin_src python

  #+end_src

- Check the result by printing ~friendships~ items:
  #+begin_src python
    [print(key,value) for key,value in friendships.items()]
  #+end_src

- Produce a count of mutual friends and exclude people already known
  to the user with the function ~friends_of_friends~:
  #+begin_src python

  #+end_src
  
- Test ~friends_of_friends~ for the users Hero (0) and Chi (3):
  #+begin_src python

  #+end_src

- These data document similar interests among the users, coded as a list of pairs:
  #+begin_src python
    interests = [
        (0, "Hadoop"), (0, "Big Data"), (0, "HBase"), (0, "Java"),
        (0, "Spark"), (0, "Storm"), (0, "Cassandra"),
        (1, "NoSQL"), (1, "MongoDB"), (1, "Cassandra"), (1, "HBase"),
        (1, "Postgres"), (2, "Python"), (2, "scikit-learn"), (2, "scipy"),
        (2, "numpy"), (2, "statsmodels"), (2, "pandas"), (3, "R"), (3, "Python"),
        (3, "statistics"), (3, "regression"), (3, "probability"),
        (4, "machine learning"), (4, "regression"), (4, "decision trees"),
        (4, "libsvm"), (5, "Python"), (5, "R"), (5, "Java"), (5, "C++"),
        (5, "Haskell"), (5, "programming languages"), (6, "statistics"),
        (6, "probability"), (6, "mathematics"), (6, "theory"),
        (7, "machine learning"), (7, "scikit-learn"), (7, "Mahout"),
        (7, "neural networks"), (8, "neural networks"), (8, "deep learning"),
        (8, "Big Data"), (8, "artificial intelligence"), (9, "Hadoop"),
        (9, "Java"), (9, "MapReduce"), (9, "Big Data")
    ]
    # print the list
    
  #+end_src

- We build a function that finds users with a certain interest:
  #+begin_src python
    
  #+end_src

- Build an index (=dict=) from interests to users:
  #+begin_src python

  #+end_src

- Build an index (=dict=) from users to interests:
  #+begin_src python

  #+end_src

- Find out who has the most interests in common with a given user:
  1. Iterate over the user's interests.
  2. For each interest, iterate over the other users with that interest.
  3. Keep count of how many times we see each other user.
  #+begin_src python

  #+end_src

  
